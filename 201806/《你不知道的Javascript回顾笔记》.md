灯！灯灯灯灯！
这篇笔记作为学习《你不知道的Javascript》回顾总结

## 大概
《你不知道的Javascript》是由Kyle Simpson在github上一直输出javascript学习笔记，后来出版。分为了六个部分，国内的几位也都翻译完出版了，分为上中下三册，本次是做上册的学习笔记，分别是“作用域和闭包”和“this和对象原型”.
## 作用域和闭包
    #### 作用域
    ![](../assets/作用域.png)
    作用域简单来说就是一个查询规则。仅仅获取值，用RHS查询。类似a = 2这种赋值操作，还需要找到变量的容器，用到LHS查询
    #### 词法作用域
    ![](../assets/词法作用域.png)
    编译阶段就定好了标识符在哪里，从而预测在执行过程中去哪儿找这些变量
    with和eval可以欺骗词法作用域，但是不要用，没意义而且降低性能
    #### 函数和块作用域
    ![](../assets/函数和块作用域.png)
    一个函数内部有一个属于自己的作用域，将里面的变量和函数隐藏起来。ES6推出的代码块也可以实现这种方法，用{}将let声明的变量藏起来。
    大家认为不应该作为替代，而是两种功能都应该存在。
    #### 提升
    声明是编译阶段的任务，复制操作是执行阶段的任务。所有由var a = 2例子来看，声明都会是在代码执行前就处理了。变量和函数的声明都会被移到作用域最顶端，这就是提升。
    函数声明会比变量声明有限，导致后面如有重复的变量声明，会被忽略掉。
    #### 作用域闭包
    ![](../assets/闭包.png)
    当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。引擎有垃圾回收器用来释放不再使用的内存空间。执行完的函数作用域自然地会考虑对其进行回收。但闭包可以阻止这件事情，使得内部作用域依然存在

## this 和 对象原型:boom
    #### this
    ![](../assets/this.png)
    只要明确this指向取决于函数在哪里被调用，就能很好的掌握它
    有时候一些操作可能会无意使用到默认绑定指向全局，产生些不好的影响。为了更安全，可以用Object.create(null)来创造一个空的非委托对象，使得一些this的操作会更安全
    #### 对象
    ![](../assets/对象.png)
    JS中“万物皆对象是错的”
    [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链
    属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别
    #### 原型
    ![](../assets/原型.png)
    所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们
    

#### 参考
* [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)